
# C语言中的宏

本文主要记录C语言中，与宏相关的奇淫巧技。

需要声明的一点是，本文按照GCC编译器与C99的标准来说明，如果使用其他编译器，
定义宏的方式都可能不同。


## 调试Macro的展开

有时候，你会奇怪为什么宏没有后按照你设计的那样运行，于是你想要找到一个办法显示宏展开后的状态。

这一节就说明使用GCC编译器如何调试宏的展开。

其实也是很简单的，你只需要在编译的时候只让build过程执行到预处理为止，
对于GCC而言，需要这样传递参数：

    gcc -E -dD obj.c -o extend.txt


简单解释下参数：
> -E: 只做预处理
> -dD: 输出的内容包括你原始定义的宏
> -o: 输出重定向

当然，如果你引入了标准库头文件，那么就会有好多的输出内容，请根据你的需要使用关键字过滤就好。

不过需要注意的是，不同的操作系统可能支持不同的编译器，并且不同的编译器支持的参数可能不同，
所以如果你得到的不是你想要的内容，请查看你的编译器文档。


## 宏中的可变参数

GCC编译器支持宏的可变参数，那么就有两个问题：

1. 如何定义(或者说传递)可变参数
2. 如何承接可变参数


简单的例子就是：

    #define MORE_ARGS(...)  __VA_ARGS__

看起来简单，不过有一些细节需要注意：
1. 可变参数必须放在最后，这与C语言其他可变参数的规则一致
2. 需要知道__VA_ARGS__配合其他的符号都干了什么


看个例子：
```C

```

输出：
```bash

```

小结：



## 宏中的 '#' 与 '##'

简单的先介绍下这两个符号的相关知识。

'#'与'##'都是编译器认识的符号，如果你了解一些编译器的知识，
你应该知道，所谓语言就是编译器认识的语言而已，它给你提供一些便于记忆的标识，仅此而已。
本文提到的这两个符号是预处理阶段解析的。

> '#'

使用'#'前缀修饰标识符，可以将标识符的字面意思转化为字符串。

> '##'

使用'##'可以将两个标识符合并成一个标识符。
需要知道的是，'##'需要两个操作数，不能当前缀或者后缀。
不过'##'可以在宏中单独使用，表示如果后面参数没有，去掉前面参数后面的多余的逗号。


看个简单栗子：
```C
#include <stdio.h>

/* implement part */

#define TO_STRING(arg) (#arg)

#define COMBO_DESCRIPTOR(one, another) (one##another)


/* test part */

int main(int argc, char ** argv){

    const char * hello_world;
    int _combo;
    const char * hello_world_combo = "hello combo";

    printf("[#] to string> got: [%s], wanted:[hello_world]\n",TO_STRING(hello_world) );

    printf("[##] combine two descriptors into one> got: [%s], wanted:[hello combo]\n",
            COMBO_DESCRIPTOR(hello_world, _combo));

    return 0;
}
```

输出：
```bash
[#] to string> got: [hello_world], wanted:[hello_world]
[##] combine two descriptors into one> got: [hello combo], wanted:[hello combo]
```

### 使用'#'与'##'实现动态计算传入宏中的参数个数

我们在StackOverflow上面看到一个比较有意思的议题，就是如何打印传递的参数个数，进而动态调用不同的函数。

[看看这里的讨论][1]

先上代码看看它的整体实现：

```C
#include <stdio.h>

#define PP_NARG(...) \
    PP_NARG_(__VA_ARGS__,PP_RSEQ_N())
#define PP_NARG_(...) \
    PP_ARG_N(__VA_ARGS__)
#define PP_ARG_N( \
     _1, _2, _3, _4, _5, _6, _7, _8, _9,_10, \
    _11,_12,_13,_14,_15,_16,_17,_18,_19,_20, \
    _21,_22,_23,_24,_25,_26,_27,_28,_29,_30, \
    _31,_32,_33,_34,_35,_36,_37,_38,_39,_40, \
    _41,_42,_43,_44,_45,_46,_47,_48,_49,_50, \
    _51,_52,_53,_54,_55,_56,_57,_58,_59,_60, \
    _61,_62,_63,  N, ...) N
#define PP_RSEQ_N() \
    63,62,61,60,                   \
    59,58,57,56,55,54,53,52,51,50, \
    49,48,47,46,45,44,43,42,41,40, \
    39,38,37,36,35,34,33,32,31,30, \
    29,28,27,26,25,24,23,22,21,20, \
    19,18,17,16,15,14,13,12,11,10, \
     9, 8, 7, 6, 5, 4, 3, 2, 1, 0

#define PRINT(pp_narg)     printf("%2d = %s\n", pp_narg, # pp_narg)

#ifndef lint
/* Prevent over-aggressive optimizers from eliminating ID string */
extern const char jlss_id_narg_c[];
const char  jlss_id_narg_c[] = "@(#)$Id: narg.c,v 1.2 2010/01/24 18:12:05 jleffler Exp $";
#endif  /* lint */

int main(int argc, char ** argv) {
    PRINT(PP_NARG(A));
    PRINT(PP_NARG(A, B));
    PRINT(PP_NARG(A, B, C));
    PRINT(PP_NARG(A, B, C, D));
    PRINT(PP_NARG(A, B, C, D, E));

    PRINT(PP_NARG(1, 2, 3, 4, 5, 6, 7, 8, 9, 0, // 1..10
                  1, 2, 3, 4, 5, 6, 7, 8, 9, 0, // 11..20
                  1, 2, 3, 4, 5, 6, 7, 8, 9, 0, // 21..30
                  1, 2, 3, 4, 5, 6, 7, 8, 9, 0, // 31..40
                  1, 2, 3, 4, 5, 6, 7, 8, 9, 0, // 41..50
                  1, 2, 3, 4, 5, 6, 7, 8, 9, 0, // 51..60
                  1, 2, 3));

    /**
    ** If the number of arguments to PP_NARG() is greater than 63, the
    ** 64th argument is returned.  This is well-defined behaviour, but
    ** not exactly what was intended.
    */
    PRINT(PP_NARG(1, 2, 3, 4, 5, 6, 7, 8, 9, 0, // 1..10
                  1, 2, 3, 4, 5, 6, 7, 8, 9, 0, // 11..20
                  1, 2, 3, 4, 5, 6, 7, 8, 9, 0, // 21..30
                  1, 2, 3, 4, 5, 6, 7, 8, 9, 0, // 31..40
                  1, 2, 3, 4, 5, 6, 7, 8, 9, 0, // 41..50
                  1, 2, 3, 4, 5, 6, 7, 8, 9, 0, // 51..60
                  1, 2, 3, -123456789));

    PRINT(PP_NARG(1, 2, 3, 4, 5, 6, 7, 8, 9, 0, // 1..10
                  1, 2, 3, 4, 5, 6, 7, 8, 9, 0, // 11..20
                  1, 2, 3, 4, 5, 6, 7, 8, 9, 0, // 21..30
                  1, 2, 3, 4, 5, 6, 7, 8, 9, 0, // 31..40
                  1, 2, 3, 4, 5, 6, 7, 8, 9, 0, // 41..50
                  1, 2, 3, 4, 5, 6, 7, 8, 9, 0, // 51..60
                  1, 2, 3, -123456789, -987654321));

    return(0);
}
```

看看输出：

    1 = PP_NARG(A)
    2 = PP_NARG(A, B)
    3 = PP_NARG(A, B, C)
    4 = PP_NARG(A, B, C, D)
    5 = PP_NARG(A, B, C, D, E)
    63 = PP_NARG(1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3)
    -123456789 = PP_NARG(1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, -123456789)
    -123456789 = PP_NARG(1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, -123456789, -987654321)


我们解释下这个程序的巧妙之处：

1. PRINT > 这个宏看起来就很简单，完成两个目的，一个是打印传入的参数个数，另一个是将参数字面意思转成字符串然后显示出来。
2. PP\_RSEQ\_N > 这个宏表示支持的最大的记录参数个数的值，注意它的顺序是倒过来的，为什么呢？因为它会从后往前'吃'，就是这样。
3.


## 编译器提供的常用宏(GCC)

```text
__func__    表示当前宏所在的函数名称字符串
__LINE__    表示当前宏所在的源文件中的行数
__FILE__    表示宏所在源文件的名字
__DATE__    编译的日期（格式"Mmm dd yyyy"）
__TIME__    编译的时间（格式"hh:mm:ss"）
__STDC__    如果编译器接受标准C，那么值为1
```


[1]: https://stackoverflow.com/questions/2308243/macro-returning-the-number-of-arguments-it-is-given-in-c

