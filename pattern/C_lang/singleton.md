---
title: 单例模式
permalink: singleton
date: 2019-10-09 23:22:51
categories: pattern
tags: singleton
---


大家好，我是“红桃C”。

这篇文章和大家讨论下单例模式的C语言实现。

对于C语言来说，由于并没有完整的类的概念，所以也不会如其他高级语言那样，需要刻意设计单例模式。

对于设计模式而言，就是一种思想，所以从理论上来讲，并不会限制由什么来实现它。

## 单例模式的概念

> 指一个类只有一个实例，且该类能自行创建这个实例的一种模式。

这是对于有‘类’这样概念的高级语言来说，对于C语言来说，可以这样描述：

一个指定类型的实例只在内存中存在一个，这个实例的构建可以是编译时静态构建的，
也可以是运行时动态创建的，外部用户需要通过统一的访问点来获得它。

## 单例模式的特点
基本上它的特点有三个

1. 内存中只有一个这样类型或者类的实例
2. 该实例对象可以静态创建和动态创建
3. 如果访问该对象，必须通过统一的访问接口

## 单例模式的设计与实现

实现代码托管在github上，可以在[这里][1]找到所有模式的实现，然后找到你关注的模式，对比本文的分析来理解。

本文使用‘身份唯一’案例，来说明：
在中国，每个人对应一个身份证，并且他的信息是唯一的，
在设计该模式的时候，需要知道两个对象，
一个是个人，也就是身份信息（被访问者）
另一个是民政局，也就是访问个人信息的机构（访问者）

代码案例实现民政局查找个人身份。

这里还是再强调下，对于C语言来说内存的分配需要自己来实现，所以也就有了，
1. 编译时，分配常驻内存的实例，对应饿汉单例模式
2. 运行时，使用malloc动态分配实例，对应懒汉单例模式

懒汉单例模式，顾名思义，就是在需要它的时候才去创建实例，实现源码在[这里][3]。
饿汉单例模式，说的是在编译构建程序时就开始创建实例，实现源码在[这里][2]。


## 单例模式的适用场景

如果说到设计模式的适用场景，一般指它的优点或者强项，毕竟只有擅长的领域才是适用场景。

优点：
占用内存少
访问效率高
频繁实例化与销毁时效率提高明显

场景：
1. 某些场景中，需要用到的实例是唯一的，即只要求生成一个对象的时候，如一个公交车的司机等。
2. 当对象实例需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如数据库的连接池等。
3. 当某类型需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。

实际应用的例子：
在计算机系统中，还有 Windows 的回收站，多线程中的线程池、显卡的驱动程序对象、数据库的连接池、应用程序中的对话框、系统中的缓存等常常被设计成单例。

## 单例模式的扩展

一般单例模式可以扩展为有限个数的多例模式，这个其实很容易扩展，按照本文的例子，自己尝试下吧。

[1]: https://github.com/OrexZ/C_pattern
[2]: https://github.com/OrexZ/C_pattern/tree/master/section_01/singleton_01
[3]: https://github.com/OrexZ/C_pattern/tree/master/section_01/singleton_02
